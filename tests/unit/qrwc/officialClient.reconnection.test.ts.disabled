/**
 * Tests for BUG-050: Insufficient reconnection window for Q-SYS Core
 */

import {
  describe,
  it,
  expect,
  jest,
  beforeEach,
  afterEach,
} from '@jest/globals';

describe('OfficialQRWCClient - Reconnection with Long-term Mode (BUG-050)', () => {
  jest.setTimeout(10000);
  let OfficialQRWCClient: any;
  let mockLogger: any;
  let mockWebSocket: any;
  let mockQrwc: any;
  let mockEmit: any;
  let clients: any[] = [];

  beforeEach(async () => {
    jest.resetModules();
    jest.clearAllMocks();
    // Don't use fake timers - they cause issues with async module loading

    // Create mock logger
    mockLogger = {
      info: jest.fn(),
      error: jest.fn(),
      warn: jest.fn(),
      debug: jest.fn(),
    };

    // Create mock WebSocket instance
    mockWebSocket = {
      on: jest.fn(),
      once: jest.fn((event, callback) => {
        if (event === 'open') {
          // Simulate immediate connection
          setImmediate(() => callback());
        }
      }),
      close: jest.fn(),
      readyState: 1, // OPEN
    };

    // Create mock QRWC instance
    mockQrwc = {
      components: {
        TestComponent: {
          controls: {
            testControl: {
              state: { Value: 0 }
            }
          }
        }
      },
      on: jest.fn(),
      close: jest.fn(),
    };

    // Mock modules
    jest.unstable_mockModule('../../../src/shared/utils/logger', () => ({
      createLogger: jest.fn().mockReturnValue(mockLogger),
      globalLogger: mockLogger,
    }));

    jest.unstable_mockModule('ws', () => ({
      default: Object.assign(jest.fn().mockImplementation(() => mockWebSocket), {
        OPEN: 1,
        CLOSED: 3,
      }),
    }));

    jest.unstable_mockModule('@q-sys/qrwc', () => ({
      Qrwc: {
        createQrwc: jest.fn().mockResolvedValue(mockQrwc),
      },
    }));

    // Import after mocking
    const module = await import('../../../src/qrwc/officialClient');
    OfficialQRWCClient = module.OfficialQRWCClient;
  });

  afterEach(async () => {
    // Clean up all clients to prevent open handles
    for (const client of clients) {
      try {
        // Remove all listeners first
        client.removeAllListeners();
        // Force disconnect
        if (client.getState() !== 'disconnected') {
          client.disconnect();
        }
      } catch (error) {
        // Ignore errors during cleanup
      }
    }
    clients = [];
    jest.clearAllMocks();
    
    // Clear any pending timers
    jest.clearAllTimers();
  });

  it('should attempt reconnection on connection failure', async () => {
    const client = new OfficialQRWCClient({
      host: 'test.local',
      port: 443,
      enableAutoReconnect: true,
      reconnectInterval: 100,
      maxReconnectAttempts: 3,
    });
    clients.push(client);

    // Track reconnecting events
    const reconnectingEvents: any[] = [];
    client.on('reconnecting', (data) => {
      reconnectingEvents.push(data);
    });

    // Make connection fail by having createQrwc reject
    const { Qrwc } = await import('@q-sys/qrwc');
    (Qrwc.createQrwc as jest.Mock).mockRejectedValueOnce(new Error('Connection failed'));

    // Trigger connection
    await expect(client.connect()).rejects.toThrow('Failed to connect to Q-SYS Core');

    // Wait a bit for reconnection to be scheduled
    await new Promise(resolve => setTimeout(resolve, 150));

    // Should have attempted reconnection
    expect(reconnectingEvents.length).toBeGreaterThan(0);
    expect(reconnectingEvents[0]).toEqual({ attempt: 1 });
  });

  it('should emit reconnecting event during reconnection attempts', async () => {
    const client = new OfficialQRWCClient({
      host: 'test.local',
      port: 443,
      enableAutoReconnect: true,
      reconnectInterval: 100,
    });
    clients.push(client);

    const reconnectingEvents: any[] = [];
    client.on('reconnecting', (data) => {
      reconnectingEvents.push(data);
    });

    // Force connection failure
    const { Qrwc } = await import('@q-sys/qrwc');
    (Qrwc.createQrwc as jest.Mock).mockRejectedValueOnce(new Error('Connection failed'));

    await expect(client.connect()).rejects.toThrow();

    // Wait for reconnection attempt
    await new Promise(resolve => setTimeout(resolve, 150));

    expect(reconnectingEvents.length).toBeGreaterThan(0);
    expect(reconnectingEvents[0]).toEqual({ attempt: 1 });
  });

  it('should track connection state changes', async () => {
    const client = new OfficialQRWCClient({
      host: 'test.local',
      port: 443,
    });
    clients.push(client);

    const stateChanges: any[] = [];
    client.on('state_change', (state) => {
      stateChanges.push(state);
    });

    // Successful connection
    const { Qrwc } = await import('@q-sys/qrwc');
    (Qrwc.createQrwc as jest.Mock).mockResolvedValueOnce(mockQrwc);

    await client.connect();

    expect(stateChanges).toContain('connecting');
    expect(stateChanges).toContain('connected');
    expect(client.getState()).toBe('connected');
  });

  it('should handle disconnection and track downtime', async () => {
    const client = new OfficialQRWCClient({
      host: 'test.local',
      port: 443,
      enableAutoReconnect: false, // Disable auto-reconnect for this test
    });
    clients.push(client);

    // Track disconnected events
    const disconnectedEvents: string[] = [];
    client.on('disconnected', (reason) => {
      disconnectedEvents.push(reason);
    });

    // Connect successfully first
    await client.connect();
    expect(client.getState()).toBe('connected');
    
    // Simulate WebSocket close
    const wsCloseCallback = mockWebSocket.on.mock.calls.find(call => call[0] === 'close')?.[1];
    if (wsCloseCallback) {
      wsCloseCallback(1000, Buffer.from('Normal closure'));
    }

    // Should emit disconnected event and change state
    expect(disconnectedEvents).toContain('Connection closed: 1000 Normal closure');
    expect(client.getState()).toBe('disconnected');
  });

  it('should respect maxReconnectAttempts configuration', async () => {
    const client = new OfficialQRWCClient({
      host: 'test.local',
      port: 443,
      enableAutoReconnect: true,
      reconnectInterval: 50,
      maxReconnectAttempts: 2,
    });
    clients.push(client);

    // Track reconnecting events
    const reconnectingEvents: any[] = [];
    client.on('reconnecting', (data) => {
      reconnectingEvents.push(data);
    });

    // Make all connection attempts fail
    const { Qrwc } = await import('@q-sys/qrwc');
    (Qrwc.createQrwc as jest.Mock).mockRejectedValue(new Error('Connection failed'));

    await expect(client.connect()).rejects.toThrow();

    // Wait for reconnection attempts
    await new Promise(resolve => setTimeout(resolve, 300));

    // Should have attempted reconnections up to max attempts and then switch to long-term mode
    // After maxReconnectAttempts, it should still continue with long-term intervals
    expect(reconnectingEvents.length).toBeGreaterThanOrEqual(2);
    
    // Verify attempt numbers increase
    const attemptNumbers = reconnectingEvents.map((e: any) => e.attempt);
    expect(attemptNumbers[0]).toBe(1);
    if (attemptNumbers.length > 1) {
      expect(attemptNumbers[1]).toBe(2);
    }
    if (attemptNumbers.length > 2) {
      expect(attemptNumbers[2]).toBe(3); // Long-term mode still increments
    }
  });

  it('should not reconnect after disconnect() is called', async () => {
    const client = new OfficialQRWCClient({
      host: 'test.local',
      port: 443,
      enableAutoReconnect: true,
    });
    clients.push(client);

    await client.connect();
    await client.disconnect();

    // Clear previous logs
    mockLogger.info.mockClear();

    // Wait a bit
    await new Promise(resolve => setTimeout(resolve, 500));

    // Should not attempt reconnection
    expect(mockLogger.info).not.toHaveBeenCalledWith(
      expect.stringContaining('Scheduling reconnection'),
      expect.any(Object)
    );
  });

  it('should emit connected event with downtime information', async () => {
    const client = new OfficialQRWCClient({
      host: 'test.local',
      port: 443,
    });
    clients.push(client);

    const connectedEvents: any[] = [];
    client.on('connected', (data) => {
      connectedEvents.push(data);
    });

    await client.connect();

    expect(connectedEvents.length).toBe(1);
    expect(connectedEvents[0]).toHaveProperty('requiresCacheInvalidation');
    expect(connectedEvents[0]).toHaveProperty('downtimeMs');
  });
});
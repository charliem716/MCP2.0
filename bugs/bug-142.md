# BUG-142: Critical Low Coverage Files Risk Production Stability

**Status**: Open  
**Severity**: High  
**Priority**: P1 (High)  
**Component**: Core Modules, Testing  
**Reported Date**: 2025-07-30  
**Reporter**: System Analysis  
**Assignee**: Unassigned

## Summary

Critical system files have dangerously low test coverage (<50%), including the main Q-SYS client (40.67%) and error recovery system (34.37%), creating significant risk for production failures.

## Description

Several core files that are essential for system operation have extremely low test coverage:

1. **officialClient.ts (40.67%)** - Main Q-SYS WebSocket connection handler
2. **error-recovery.ts (34.37%)** - System-wide error recovery logic  
3. **env.ts (43.75%)** - Configuration and environment management

These files handle critical functions like:
- WebSocket connection lifecycle
- Error recovery and retry logic
- System configuration loading
- Production environment detection

Low coverage in these areas means most error paths and edge cases are untested.

## Steps to Reproduce

1. Generate coverage report: `npm run test:coverage`
2. Open `coverage/lcov-report/src/qrwc/officialClient.ts.html`
3. Observe large sections of red (untested) code
4. Note critical functions with 0% coverage
5. Repeat for error-recovery.ts and env.ts

## Expected Behavior

Critical infrastructure files should have:
- Minimum 80% coverage (per project standards)
- 100% coverage for error handling paths
- Full coverage of connection state transitions
- All configuration scenarios tested

## Actual Behavior

- officialClient.ts: Only happy path tested, no error scenarios
- error-recovery.ts: Recovery strategies completely untested
- env.ts: Environment detection and fallbacks untested

## Environment

- **Impact**: All environments (development, staging, production)
- **Risk Level**: HIGH - These files run in every deployment
- **User Impact**: Connection failures, unhandled errors, misconfigurations

## Error Logs/Stack Trace

Example untested code sections:
```typescript
// officialClient.ts - Connection error handling (0% coverage)
private handleConnectionError(error: Error): void {
  this.logger.error('Connection failed', { error });
  if (this.shouldRetry(error)) {
    this.scheduleReconnection();
  } else {
    this.emitFatalError(error);
  }
}

// error-recovery.ts - Recovery strategies (0% coverage)
export async function recoverFromError(error: Error): Promise<void> {
  const strategy = selectRecoveryStrategy(error);
  if (strategy) {
    await strategy.execute();
  } else {
    throw new UnrecoverableError(error);
  }
}
```

## Root Cause Analysis

- **Historical Issue**: These files were written early without TDD
- **Complexity**: WebSocket and async error handling are hard to test
- **Technical Debt**: Tests were deferred and never written
- **Mocking Challenges**: External dependencies (WebSocket, file system) require complex mocks

## Proposed Solution

### Phase 1: Integration Tests for officialClient.ts (1 day)
```typescript
// Use WebSocket mock server
import { WebSocketServer } from 'ws';

describe('OfficialQRWCClient integration', () => {
  let mockServer: WebSocketServer;
  
  beforeEach(() => {
    mockServer = new WebSocketServer({ port: 8080 });
  });
  
  it('should handle connection failures', async () => {
    mockServer.close(); // Force connection failure
    const client = new OfficialQRWCClient(config);
    await expect(client.connect()).rejects.toThrow();
  });
  
  it('should reconnect after disconnect', async () => {
    // Test reconnection logic
  });
});
```

### Phase 2: Error Recovery Tests (0.5 days)
```typescript
describe('Error Recovery System', () => {
  it('should recover from transient errors', async () => {
    const error = new NetworkError('Temporary failure');
    await expect(recoverFromError(error)).resolves.not.toThrow();
  });
  
  it('should not recover from fatal errors', async () => {
    const error = new AuthenticationError('Invalid credentials');
    await expect(recoverFromError(error)).rejects.toThrow();
  });
});
```

### Phase 3: Environment Configuration Tests (0.5 days)
```typescript
describe('Environment Configuration', () => {
  it('should load from env vars', () => {
    process.env.QSYS_HOST = 'test.local';
    expect(loadConfig().host).toBe('test.local');
  });
  
  it('should fall back to config file', () => {
    delete process.env.QSYS_HOST;
    expect(loadConfig().host).toBe('configured.host');
  });
});
```

## Workaround

No safe workaround - these files must be properly tested before production deployment.

## Test Cases

- [ ] WebSocket connection success/failure scenarios
- [ ] Reconnection with exponential backoff
- [ ] All error types trigger appropriate recovery
- [ ] Configuration loading from all sources
- [ ] State transitions are logged correctly
- [ ] Memory leaks prevention in reconnection
- [ ] Timeout handling in all async operations

## Related Issues

- Parent: BUG-107 (test coverage below threshold)
- Related: BUG-141 (general coverage issues)
- Blocks: Production deployment

## Additional Context

**Security Implications**: 
- Untested error paths may leak sensitive information
- Configuration loading bugs could expose credentials

**Performance Impact**:
- Untested reconnection logic may cause connection storms
- Error recovery loops could consume excessive resources

**Previous Attempts Failed** (from BUG-107):
- Complex WebSocket mocking was attempted but abandoned
- Need to use integration testing approach instead

## Acceptance Criteria

- [ ] officialClient.ts coverage > 80%
- [ ] error-recovery.ts coverage > 80%  
- [ ] env.ts coverage > 80%
- [ ] All error paths have explicit tests
- [ ] No flaky tests introduced
- [ ] Tests run in < 30 seconds
- [ ] Clear documentation for test maintenance

## Notes

This is the highest priority coverage issue. These files are the foundation of the system and must be thoroughly tested. Consider bringing in a testing expert or dedicating a full sprint to this issue.

---

**Labels**: bug, critical, testing, infrastructure, production-blocker  
**Milestone**: Production Readiness
# BUG-171: Implement Database Backup and Recovery Strategy

**Status**: Open  
**Severity**: Low  
**Priority**: P3 (Low)  
**Component**: database, backup  
**Reported Date**: 2025-08-07  
**Reporter**: Assistant  
**Assignee**: Unassigned

## Summary

No database backup strategy or recovery procedures exist, risking data loss in production.

## Description

Missing backup features:
- No automated backups
- No recovery procedures
- No data export functionality
- No integrity checks
- No disaster recovery plan
- No backup retention policy

Risks:
- Complete data loss possible
- No recovery from corruption
- No historical data preservation
- Extended downtime for recovery

## Steps to Reproduce

1. Check for backup procedures - none exist
2. Simulate database corruption
3. Attempt recovery - no process
4. Look for backup files - none created
5. Try to export data - no functionality

## Expected Behavior

- Automated daily backups
- Point-in-time recovery
- Data export/import tools
- Integrity verification
- Documented recovery procedures
- Backup retention management

## Actual Behavior

- No backups
- No recovery capability
- No export tools
- No integrity checks
- No documentation

## Environment

- **Database**: SQLite
- **Storage**: Local filesystem
- **Data Volume**: GB+ of events

## Error Logs/Stack Trace

```
Database corruption detected
No backup available for recovery
Data loss: 7 days of events
```

## Root Cause Analysis

- Backup not implemented
- No disaster recovery planning
- SQLite backup API not utilized
- No scheduled maintenance tasks

## Proposed Solution

```typescript
// Backup manager
class BackupManager {
  private backupPath = '/var/backups/mcp';
  private retentionDays = 30;
  
  async performBackup() {
    const timestamp = new Date().toISOString().replace(/:/g, '-');
    const backupFile = `${this.backupPath}/events-${timestamp}.db`;
    
    try {
      // Use SQLite backup API
      await this.db.backup(backupFile);
      
      // Verify backup integrity
      const backup = new Database(backupFile, { readonly: true });
      const check = backup.prepare('PRAGMA integrity_check').get();
      backup.close();
      
      if (check.integrity_check !== 'ok') {
        throw new Error('Backup integrity check failed');
      }
      
      // Compress backup
      await this.compress(backupFile);
      
      // Clean old backups
      await this.cleanOldBackups();
      
      logger.info('Backup completed', { file: backupFile });
      
    } catch (error) {
      logger.error('Backup failed', { error });
      throw error;
    }
  }
  
  async restore(backupFile: string) {
    logger.info('Starting restore', { file: backupFile });
    
    // Verify backup
    const backup = new Database(backupFile, { readonly: true });
    const check = backup.prepare('PRAGMA integrity_check').get();
    
    if (check.integrity_check !== 'ok') {
      throw new Error('Backup file corrupted');
    }
    
    // Stop services
    await this.stopServices();
    
    // Restore database
    await fs.copyFile(backupFile, this.dbPath);
    
    // Restart services
    await this.startServices();
    
    logger.info('Restore completed');
  }
  
  async exportData(startTime: number, endTime: number) {
    const events = await this.db.prepare(`
      SELECT * FROM events 
      WHERE timestamp BETWEEN ? AND ?
    `).all(startTime, endTime);
    
    const exportFile = `export-${Date.now()}.json`;
    await fs.writeFile(exportFile, JSON.stringify(events, null, 2));
    
    return exportFile;
  }
  
  scheduleBackups() {
    // Daily at 2 AM
    cron.schedule('0 2 * * *', () => {
      this.performBackup().catch(error => {
        logger.error('Scheduled backup failed', { error });
      });
    });
  }
}

// Recovery procedures document
## Disaster Recovery Procedures

### Scenario 1: Database Corruption
1. Stop MCP server
2. Identify latest clean backup
3. Run: npm run restore -- --file=/backups/latest.db
4. Verify data integrity
5. Restart services

### Scenario 2: Accidental Deletion
1. Stop write operations
2. Export recent data if possible
3. Restore from backup
4. Re-import recent data

### Scenario 3: Hardware Failure
1. Provision new server
2. Install MCP server
3. Restore latest backup
4. Update configuration
5. Resume operations
```

## Workaround

Manual database file copies

## Test Cases

- [ ] Automated backup runs successfully
- [ ] Backup integrity verified
- [ ] Restore procedure works
- [ ] Old backups cleaned up
- [ ] Export functionality works
- [ ] Recovery time < 30 minutes

## Related Issues

- Related to: Production reliability
- Important for: Data protection

## Additional Context

- Required for production data safety
- Compliance requirement
- Disaster recovery capability
- Customer confidence

## Acceptance Criteria

- [ ] Automated daily backups
- [ ] Backup integrity verification
- [ ] Restore procedure tested
- [ ] Export/import tools created
- [ ] Recovery documentation complete
- [ ] Backup retention implemented

## Notes

Critical for production but not blocking initial deployment

---

**Labels**: bug, database, backup, disaster-recovery  
**Milestone**: Production Readiness
# BUG-074: CircularBuffer queryTimeRange not working, forcing O(n) performance

**Status**: Open  
**Severity**: High  
**Priority**: P1 (High)  
**Component**: State Management / Event Cache  
**Reported Date**: 2025-07-23  
**Reporter**: System Analysis  
**Assignee**: Unassigned  

## Summary
The queryTimeRange method in CircularBuffer is not functioning correctly, forcing the EventCacheManager to use getAll() with manual filtering, resulting in O(n) performance instead of O(log n).

## Description
The CircularBuffer implementation includes a SortedArray time index designed for efficient O(log n) time-range queries. However, the EventCacheManager contains a comment "Use getAll() and filter by time manually until queryTimeRange is fixed" and implements a workaround that defeats the purpose of the index. This causes:
- Poor query performance on large buffers
- Unnecessary memory allocation for all events
- Scalability issues with high-frequency event streams
- Violation of performance requirements for 100k+ events

## Steps to Reproduce
1. Create a CircularBuffer with 10,000 events
2. Add events with sequential timestamps
3. Call queryTimeRange for a small time window (e.g., last 100 events)
4. Observe that the current implementation retrieves all 10,000 events
5. Profile the operation to confirm O(n) performance

## Expected Behavior
- queryTimeRange should use the SortedArray index
- Only events within the time range should be retrieved
- Performance should be O(log n) for index lookup + O(k) for k results
- Memory usage should be proportional to results, not total buffer size

## Actual Behavior
- getAll() retrieves entire buffer contents
- Manual filtering iterates through all events
- Performance is O(n) where n is total buffer size
- Memory spikes during queries on large buffers

## Environment
- **OS**: All
- **Node.js Version**: v20.11.0+
- **Project Version/Commit**: Current main branch

## Error Logs/Stack Trace
```typescript
// From src/mcp/state/event-cache/manager.ts:254-258
// Use getAll() and filter by time manually until queryTimeRange is fixed
const allEvents = (buffer as any).getAll ? (buffer as any).getAll() : [];
const events = allEvents.filter((e: CachedEvent) => 
  e.timestampMs >= startTime && e.timestampMs <= endTime
);
```

## Root Cause Analysis
- **File(s)**: src/mcp/state/event-cache/circular-buffer.ts
- **Line(s)**: 72-84 (queryTimeRange method)
- **Cause**: The issue appears to be with how the SortedArray indices map to circular buffer positions after wraparound

## Proposed Solution
```typescript
// Fix queryTimeRange to handle circular buffer wraparound correctly
queryTimeRange(startTime: bigint, endTime: bigint): T[] {
  const indices = this.timeIndex.findInRange(startTime, endTime);
  const results: T[] = [];
  
  for (const bufferIdx of indices) {
    // Validate index is still valid (not overwritten)
    if (this.isValidIndex(bufferIdx)) {
      const event = this.buffer[bufferIdx];
      if (event && event.timestamp >= startTime && event.timestamp <= endTime) {
        results.push(event.data);
      }
    }
  }
  
  return results;
}

private isValidIndex(idx: number): boolean {
  // Check if index is within current valid range
  if (this.size < this.capacity) {
    // Buffer not full yet
    return idx >= 0 && idx < this.size;
  } else {
    // Buffer is circular, check if index is in valid range
    if (this.tail <= this.head) {
      return idx >= this.tail && idx < this.head;
    } else {
      // Wrapped around
      return idx >= this.tail || idx < this.head;
    }
  }
}

// Alternative: Maintain index validity during overwrite
add(data: T, timestamp?: bigint): void {
  // ... existing code ...
  
  // When overwriting, update all indices that pointed to old position
  if (this.size === this.capacity) {
    const oldEvent = this.buffer[this.head];
    if (oldEvent) {
      this.timeIndex.remove(oldEvent.timestamp);
      // Update any stale index references
      this.timeIndex.updateIndicesAfterOverwrite(this.head);
    }
  }
  
  // ... rest of method
}
```

## Workaround
None - the current getAll() approach is the workaround, but it has severe performance implications.

## Test Cases
- [ ] Unit test: queryTimeRange returns correct events for time window
- [ ] Unit test: queryTimeRange handles circular wraparound
- [ ] Unit test: queryTimeRange handles overwritten indices
- [ ] Performance test: Verify O(log n) performance on 100k events
- [ ] Edge case: Query spanning wraparound boundary
- [ ] Edge case: Query when buffer is exactly full
- [ ] Stress test: Concurrent adds during query

## Related Issues
- Related to: BUG-072 (Event Cache Manager implementation)
- Blocks: Performance requirements for production

## Additional Context
- This is a critical performance issue that prevents the Event Cache from meeting its design goals
- The time index is properly maintained but not properly used
- May require redesigning how indices map to circular positions

## Acceptance Criteria
- [ ] queryTimeRange uses the SortedArray index
- [ ] Query performance is O(log n) + O(k) for k results
- [ ] EventCacheManager uses queryTimeRange instead of getAll()
- [ ] Performance tests confirm sub-100ms queries on 100k events
- [ ] All existing tests still pass
- [ ] No memory leaks or invalid references

## Notes
This bug effectively makes the Event Cache unsuitable for high-frequency data. The fix is critical for meeting the 33Hz update rate requirement with historical queries.

---
**Labels**: bug, event-cache, performance, high-priority  
**Milestone**: Event Cache GA
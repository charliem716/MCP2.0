# BUG-039: Overly Complex LRU Cache Implementation

**Status**: Open  
**Severity**: Medium  
**Priority**: P2 (Medium)  
**Component**: State Management / LRU Cache  
**Reported Date**: 2025-01-20  
**Reporter**: Phase-2 Audit  
**Assignee**: Unassigned  

## Summary
The LRU Cache implementation is unnecessarily complex with features that aren't utilized, making it harder to maintain than needed.

## Description
The current LRU Cache includes:
- TTL (Time To Live) support that isn't used
- Complex eviction policies beyond basic LRU
- Event system for cache operations
- Serialization support not required for in-memory cache
- Multiple storage backends for simple memory cache

This adds:
- Unnecessary code complexity
- Increased testing burden
- Potential for bugs in unused features
- Confusion about which features to use

## Steps to Reproduce
1. Review `src/mcp/state/lru-cache.ts`
2. Search for usage of TTL, events, and serialization features
3. Expected result: Features in use throughout codebase
4. Actual result: Most advanced features unused

## Expected Behavior
A simple LRU cache that:
- Stores key-value pairs
- Evicts least recently used items when full
- Provides get/set/delete operations
- Has configurable size limit

## Actual Behavior
Complex implementation with TTL, events, serialization, and multiple storage backends that aren't utilized.

## Environment
- **OS**: All
- **Node.js Version**: v20.x
- **Project Version/Commit**: bug/001-fix branch

## Root Cause Analysis
- **File(s)**: `src/mcp/state/lru-cache.ts`
- **Cause**: Over-engineering for potential future needs that haven't materialized

## Proposed Solution
```typescript
// Simplified LRU Cache using Map's insertion order
class SimpleLRUCache<K, V> {
  private cache = new Map<K, V>();
  
  constructor(private maxSize: number) {}
  
  get(key: K): V | undefined {
    const value = this.cache.get(key);
    if (value !== undefined) {
      // Move to end (most recent)
      this.cache.delete(key);
      this.cache.set(key, value);
    }
    return value;
  }
  
  set(key: K, value: V): void {
    this.cache.delete(key); // Remove if exists
    this.cache.set(key, value);
    
    if (this.cache.size > this.maxSize) {
      // Remove oldest (first) entry
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
  }
  
  delete(key: K): boolean {
    return this.cache.delete(key);
  }
  
  clear(): void {
    this.cache.clear();
  }
}
```

## Test Cases
- [ ] Test basic get/set operations
- [ ] Test LRU eviction when cache is full
- [ ] Test item promotion on access
- [ ] Performance test with large datasets

## Related Issues
- Related to: Code simplicity and maintainability

## Acceptance Criteria
- [ ] Simplified implementation with core LRU functionality
- [ ] No loss of required features
- [ ] Improved performance due to simpler code
- [ ] Comprehensive tests for LRU behavior

---
**Labels**: bug, state-management, medium-priority, refactoring
# BUG-172: Add Health Check Endpoint and Monitoring Metrics

**Status**: Open  
**Severity**: Medium  
**Priority**: P2 (Medium)  
**Component**: monitoring, api  
**Reported Date**: 2025-08-07  
**Reporter**: Assistant  
**Assignee**: Unassigned

## Summary

No health check endpoint exists for monitoring system status and readiness in production.

## Description

Missing monitoring capabilities:
- No /health endpoint
- No /metrics endpoint
- No readiness checks
- No liveness probes
- No performance metrics exposed
- No integration with monitoring tools

This prevents:
- Kubernetes health checks
- Load balancer health monitoring
- Prometheus metrics scraping
- Alerting on issues
- Proactive problem detection

## Steps to Reproduce

1. Try to access /health endpoint - doesn't exist
2. Attempt Kubernetes deployment - no probes
3. Setup monitoring - no metrics available
4. Configure alerts - no data source
5. Check system status - manual only

## Expected Behavior

```json
GET /health
{
  "status": "healthy",
  "timestamp": "2025-01-07T10:00:00Z",
  "uptime": 3600,
  "version": "1.0.0",
  "checks": {
    "database": "healthy",
    "qsys": "connected",
    "memory": "ok"
  }
}

GET /metrics
# HELP mcp_events_total Total events processed
# TYPE mcp_events_total counter
mcp_events_total 1234567
```

## Actual Behavior

- No health endpoint
- No metrics endpoint
- No monitoring capability

## Environment

- **Deployment**: Kubernetes, Docker, PM2
- **Monitoring**: Prometheus, Grafana
- **Load Balancer**: Any

## Error Logs/Stack Trace

```
Kubernetes: Readiness probe failed: connection refused
Load Balancer: Health check failed
Prometheus: No metrics endpoint found
```

## Root Cause Analysis

- Health endpoints not implemented
- No metrics collection
- No monitoring consideration
- Missing production requirements

## Proposed Solution

```typescript
// Health check implementation
import express from 'express';
import promClient from 'prom-client';

const app = express();
const register = new promClient.Registry();

// Metrics
const eventsProcessed = new promClient.Counter({
  name: 'mcp_events_processed_total',
  help: 'Total events processed',
  labelNames: ['type', 'group']
});

const queryDuration = new promClient.Histogram({
  name: 'mcp_query_duration_seconds',
  help: 'Query duration in seconds',
  buckets: [0.1, 0.5, 1, 2, 5]
});

register.registerMetric(eventsProcessed);
register.registerMetric(queryDuration);

// Health check
app.get('/health', async (req, res) => {
  const health = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    version: process.env.npm_package_version,
    pid: process.pid,
    memory: {
      used: process.memoryUsage().heapUsed,
      total: process.memoryUsage().heapTotal,
      percentage: (process.memoryUsage().heapUsed / process.memoryUsage().heapTotal) * 100
    },
    checks: {}
  };
  
  // Check database
  try {
    const dbStats = await eventMonitor.getStatistics();
    health.checks.database = {
      status: 'healthy',
      events: dbStats.totalEvents,
      size: dbStats.databaseSize
    };
  } catch (error) {
    health.checks.database = {
      status: 'unhealthy',
      error: error.message
    };
    health.status = 'degraded';
  }
  
  // Check Q-SYS connection
  health.checks.qsys = {
    status: qsysClient.isConnected() ? 'connected' : 'disconnected',
    lastPing: qsysClient.getLastPing()
  };
  
  if (!qsysClient.isConnected()) {
    health.status = 'degraded';
  }
  
  // Check memory pressure
  if (health.memory.percentage > 80) {
    health.checks.memory = {
      status: 'warning',
      message: 'High memory usage'
    };
    health.status = 'degraded';
  }
  
  const statusCode = health.status === 'healthy' ? 200 : 503;
  res.status(statusCode).json(health);
});

// Readiness check (for Kubernetes)
app.get('/ready', async (req, res) => {
  const ready = 
    qsysClient.isConnected() && 
    eventMonitor.isEnabled();
    
  res.status(ready ? 200 : 503).json({ ready });
});

// Liveness check (for Kubernetes)
app.get('/alive', (req, res) => {
  res.status(200).json({ alive: true });
});

// Metrics endpoint
app.get('/metrics', async (req, res) => {
  res.set('Content-Type', register.contentType);
  const metrics = await register.metrics();
  res.end(metrics);
});

// Kubernetes deployment
apiVersion: v1
kind: Service
spec:
  ports:
    - name: http
      port: 3000
    - name: metrics
      port: 9090
---
apiVersion: apps/v1
kind: Deployment
spec:
  template:
    spec:
      containers:
      - name: mcp-server
        livenessProbe:
          httpGet:
            path: /alive
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 10
          periodSeconds: 5
```

## Workaround

Manual health checks only

## Test Cases

- [ ] /health endpoint returns correct status
- [ ] /metrics endpoint provides Prometheus format
- [ ] /ready endpoint reflects readiness
- [ ] /alive endpoint always responds
- [ ] Degraded status when issues detected
- [ ] Kubernetes probes work correctly

## Related Issues

- Related to: BUG-164 (Logging and Monitoring)
- Required for: Production deployment

## Additional Context

- Essential for production monitoring
- Required for Kubernetes deployment
- Enables proactive alerting
- Standard production requirement

## Acceptance Criteria

- [ ] /health endpoint implemented
- [ ] /metrics endpoint with Prometheus format
- [ ] /ready and /alive for Kubernetes
- [ ] All system checks included
- [ ] Documentation updated
- [ ] Grafana dashboard example

## Notes

Important for production monitoring and operations

---

**Labels**: bug, monitoring, api, production  
**Milestone**: Production Readiness
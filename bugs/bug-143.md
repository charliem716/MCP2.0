# BUG-143: Medium Coverage Files Need Tests for 80% Threshold

**Status**: Open  
**Severity**: Medium  
**Priority**: P2 (Medium)  
**Component**: MCP Tools, Testing  
**Reported Date**: 2025-07-30  
**Reporter**: System Analysis  
**Assignee**: Unassigned

## Summary

Several MCP tool files have medium coverage (60-75%) that need improvement to reach the 80% threshold, representing quick wins for overall coverage improvement.

## Description

While critical files have dangerously low coverage (BUG-142), several files are closer to the 80% target and represent easier wins:

1. **components.ts (60.6%)** - Component discovery and formatting
2. **status.ts (71.09%)** - Core status reporting  
3. **controls.ts (75.61%)** - Control manipulation logic

These files need focused effort on:
- Error handling paths
- Edge cases in formatting functions
- Type determination branches
- Default parameter handling

Additionally, there are "quick win" opportunities across the codebase that could add 3-5% coverage with minimal effort.

## Steps to Reproduce

1. Run `npm run test:coverage`
2. Open coverage report for:
   - `coverage/lcov-report/src/mcp/tools/components.ts.html`
   - `coverage/lcov-report/src/mcp/tools/status.ts.html`
   - `coverage/lcov-report/src/mcp/tools/controls.ts.html`
3. Observe yellow/red sections indicating partial or no coverage
4. Note these files are 5-20% away from 80% target

## Expected Behavior

- All tool files should have ≥80% coverage
- Error handling branches should be fully tested
- Type determination logic should cover all cases
- Formatting functions should handle edge cases

## Actual Behavior

- components.ts: Missing error path tests, formatResponse edge cases
- status.ts: Incomplete coverage of status formatting conditions
- controls.ts: Type determination branches untested
- Multiple files missing simple tests (toJSON, getters, defaults)

## Environment

- **Test Framework**: Jest v29
- **Impact**: These are user-facing tool implementations
- **Risk**: Medium - bugs here affect AI agent interactions

## Error Logs/Stack Trace

Example untested sections:
```typescript
// components.ts - Error formatting (untested)
catch (error) {
  return {
    error: true,
    message: error instanceof Error ? error.message : 'Unknown error'
  };
}

// status.ts - Conditional formatting (partial coverage)
includeNetworkInfo ? {
  ip: status.ip || 'Unknown',
  port: status.port || 0
} : undefined

// controls.ts - Type inference (untested branches)
if (name.includes('gain') || name.includes('level')) {
  return 'continuous';
} else if (name.includes('mute')) {
  return 'boolean';
}
return 'unknown';
```

## Root Cause Analysis

- **Testing Strategy**: Focused on happy paths, missed edge cases
- **Time Pressure**: Tests written quickly without branch analysis
- **Incremental Development**: Features added without corresponding tests

## Proposed Solution

### Phase 1: Quick Wins (4-6 hours)
```typescript
// Test all error classes' toJSON methods
describe('Error serialization', () => {
  it('should serialize QSysError to JSON', () => {
    const error = new QSysError('Test', 'CONN_001');
    expect(error.toJSON()).toEqual({
      name: 'QSysError',
      message: 'Test',
      code: 'CONN_001'
    });
  });
});

// Test default parameters
it('should use default ramp time when not specified', () => {
  const result = setControlValue('gain', -10);
  expect(result.ramp).toBe(0); // default
});

// Test getters/setters
it('should get/set connection state', () => {
  adapter.connectionState = 'connected';
  expect(adapter.connectionState).toBe('connected');
});
```

### Phase 2: Tool-Specific Tests (1 day)
```typescript
// components.ts edge cases
describe('formatComponentResponse edge cases', () => {
  it('should handle components without properties', () => {
    const result = formatResponse(null);
    expect(result.error).toBe(true);
  });
  
  it('should handle malformed component data', () => {
    const result = formatResponse({ Components: [{ Name: null }] });
    expect(result.components).toHaveLength(0);
  });
});

// status.ts conditional branches
describe('status formatting options', () => {
  it('should exclude network info when not requested', () => {
    const result = formatStatus(data, { includeNetworkInfo: false });
    expect(result.network).toBeUndefined();
  });
});

// controls.ts type determination
describe('control type inference', () => {
  test.each([
    ['master_gain', 'continuous'],
    ['zone1_mute', 'boolean'],
    ['preset_recall', 'trigger'],
    ['unknown_control', 'unknown']
  ])('should infer type for %s as %s', (name, type) => {
    expect(inferControlType(name)).toBe(type);
  });
});
```

### Phase 3: Refactoring Recommendations (for future)
```typescript
// Extract pure functions for easier testing
export function inferControlType(name: string): ControlType {
  // Move logic here from class method
}

// Add dependency injection for testability
class ComponentTool {
  constructor(private adapter = getDefaultAdapter()) {}
}
```

## Workaround

Focus on BUG-142 critical files first, then return to these medium-coverage files.

## Test Cases

Quick wins:
- [ ] All error classes have toJSON tests
- [ ] All tools test default parameter values
- [ ] Getter/setter methods have basic tests
- [ ] Static utility functions fully covered

Tool-specific:
- [ ] components.ts: formatResponse error cases
- [ ] components.ts: Property filtering logic
- [ ] status.ts: All include/exclude flag combinations
- [ ] status.ts: Missing/null field handling
- [ ] controls.ts: Type inference for all patterns
- [ ] controls.ts: Ramp parameter edge cases

## Related Issues

- Parent: BUG-107 (test coverage below threshold)
- Related: BUG-141 (general coverage improvement)
- Blocks: 80% coverage requirement

## Additional Context

**Previous Failed Attempts** (from BUG-107):
- Adding tests to existing files caused mock conflicts
- Solution: Create separate test files for edge cases
- Use `describe.skip()` to isolate problematic tests

**Lessons Learned**:
- Don't modify existing test files - create new ones
- Use data-driven tests (test.each) for type inference
- Mock at the adapter level, not individual functions

## Acceptance Criteria

- [ ] components.ts coverage ≥ 80%
- [ ] status.ts coverage ≥ 80%  
- [ ] controls.ts coverage ≥ 80%
- [ ] Overall project coverage increases by 3-5%
- [ ] No existing tests break
- [ ] New tests are maintainable and clear

## Notes

These represent the "low-hanging fruit" for coverage improvement. A focused day of effort here could significantly boost overall metrics and uncover hidden bugs in error paths.

---

**Labels**: bug, testing, coverage, medium-priority, quick-win  
**Milestone**: Coverage Improvement Sprint
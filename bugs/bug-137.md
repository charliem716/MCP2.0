# BUG-137: Lack of Dependency Injection Leading to High Coupling and Poor Testability

**Status**: Open
**Severity**: High
**Priority**: P1 (High)
**Component**: Core Architecture, Testing
**Reported Date**: 2025-07-29
**Reporter**: Gemini
**Assignee**: Unassigned

## Summary

The codebase exhibits high coupling between classes, as components create their own dependencies directly (e.g., using the `new` keyword). This makes the system rigid and difficult to test in isolation, leading to complex, brittle tests that rely on extensive mocking of the entire dependency tree.

## Description

Throughout the application, classes are responsible for instantiating their own dependencies. For example, a server class might create its own QRWC client adapter, which in turn creates its own client. This tight coupling means:

- **Unit testing is difficult:** It's impossible to test a single class without also testing its dependencies. This leads to integration tests being used where unit tests would be more appropriate.
- **Mocks are complex:** To test a class, we have to mock not just its direct dependencies, but the dependencies of its dependencies, and so on. This makes tests fragile and hard to maintain.
- **Code is not reusable:** A class cannot be used in a different context with a different implementation of its dependencies.

## Steps to Reproduce

1.  Examine the constructor of `MCPServer` in `src/mcp/server.ts`.
2.  Notice that it creates its own `QRWCClientAdapter` instance.
3.  Attempt to write a unit test for `MCPServer` that uses a mock `QRWCClientAdapter`.
4.  Observe that this requires complex module-level mocking with `jest.mock` or `jest.unstable_mockModule` rather than simply passing a mock object to the constructor.

## Expected Behavior

- Classes should receive their dependencies through their constructor (Dependency Injection).
- Unit tests should be simple to write, with mock dependencies passed directly to the class being tested.
- The system should be composed of loosely coupled, easily replaceable components.

## Actual Behavior

The current implementation leads to a rigid architecture where components are not easily interchangeable, and testing is more complex than necessary.

## Proposed Solution

Adopt Dependency Injection (DI) across the codebase. Dependencies should be created in a single, top-level composition root (e.g., in `src/index.ts`) and passed down to the components that need them.

**Example Refactoring of `MCPServer`:**

**Before:**
```typescript
// src/mcp/server.ts
export class MCPServer {
  private client: QRWCClientAdapter;

  constructor() {
    this.client = new QRWCClientAdapter(); // Dependency created internally
  }
}
```

**After:**
```typescript
// src/mcp/server.ts
export class MCPServer {
  private client: QRWCClientAdapter;

  constructor(client: QRWCClientAdapter) { // Dependency is injected
    this.client = client;
  }
}

// src/index.ts (Composition Root)
const clientAdapter = new QRWCClientAdapter();
const server = new MCPServer(clientAdapter);
server.start();
```

## Test Cases

- [ ] All major components (`MCPServer`, `QRWCClientAdapter`, etc.) are refactored to use constructor-based dependency injection.
- [ ] Unit tests are updated to pass mock dependencies directly to the constructor, removing the need for complex module-level mocks.
- [ ] The application's entry point (`src/index.ts`) acts as the composition root, creating and injecting all dependencies.

## Related Issues

- **Impacts:** BUG-133, BUG-134

## Acceptance Criteria

- [ ] No class in the `src` directory should instantiate another class from a different module in its constructor.
- [ ] All dependencies are provided via the constructor.
- [ ] All relevant unit tests are updated to use the new constructor injection pattern.

---

**Labels**: bug, technical-debt, architecture, testing
**Milestone**: Core Refactoring

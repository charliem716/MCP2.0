# BUG-072: Event Cache Manager needed for Change Group historical queries

**Status**: Open  
**Severity**: High  
**Priority**: P1 (High)  
**Component**: State Management / MCP Tools  
**Reported Date**: 2025-07-23  
**Reporter**: System Analysis  
**Assignee**: Unassigned  

## Summary
No event cache management system exists to capture, store, and query historical Change Group events, preventing implementation of time-based queries like "Which controls changed in the last 5 minutes?"

## Description
The Event Cache Manager is needed to:
- Listen to Change Group events from QRWCAdapter
- Store events in circular buffers with time-series indexing
- Provide query interface for historical data
- Manage memory and compression for long-term storage
- Support multiple change groups with different retention policies
- Enable MCP tools to query event history

Without this component, Change Groups can only provide current state, not historical analysis.

## Steps to Reproduce
1. Create a change group and enable auto-polling
2. Let it run for several minutes with control changes
3. Try to query what changed in the last 5 minutes
4. Observe that no historical data is available

## Expected Behavior
An Event Cache Manager should:
- Automatically capture all Change Group events
- Store them with nanosecond-precision timestamps
- Allow queries by time range, control name, and value
- Return historical event data for analysis
- Manage memory efficiently with configurable limits

## Actual Behavior
- No event history is maintained
- Only current state is available via polling
- No way to analyze patterns over time
- No historical debugging capabilities

## Environment
- **OS**: All
- **Node.js Version**: v20.11.0+
- **Project Version/Commit**: Current main branch

## Error Logs/Stack Trace
N/A - Missing functionality

## Root Cause Analysis
- **File(s)**: N/A - Not implemented
- **Line(s)**: N/A
- **Cause**: Original Change Group design focused on current state, not historical analysis

## Proposed Solution
```typescript
// Create src/mcp/state/event-cache/manager.ts

import { EventEmitter } from 'events';
import { CircularBuffer } from './circular-buffer.js';
import { QRWCAdapter } from '../../qrwc/adapter.js';

export interface CachedEvent {
  groupId: string;
  controlName: string;
  timestamp: bigint;
  timestampMs: number;
  value: unknown;
  string: string;
  previousValue?: unknown;
  previousString?: string;
  delta?: number;
  duration?: number;
  sequenceNumber: number;
}

export interface EventQuery {
  groupId?: string;
  startTime?: number;
  endTime?: number;
  controlNames?: string[];
  valueFilter?: {
    operator: 'eq' | 'neq' | 'gt' | 'lt' | 'changed_to' | 'changed_from';
    value: unknown;
  };
  limit?: number;
  aggregation?: 'raw' | 'changes_only' | 'summary';
}

export class EventCacheManager extends EventEmitter {
  private buffers: Map<string, CircularBuffer<CachedEvent>>;
  private globalSequence: number = 0;
  private lastValues: Map<string, Map<string, unknown>>;
  
  constructor(
    private defaultConfig: {
      maxEvents: number;
      maxAgeMs: number;
    } = {
      maxEvents: 100000,
      maxAgeMs: 3600000 // 1 hour
    }
  ) {
    super();
    this.buffers = new Map();
    this.lastValues = new Map();
  }
  
  attachToAdapter(adapter: QRWCAdapter): void {
    adapter.on('changeGroup:changes', (event) => {
      this.handleChangeEvent(event);
    });
  }
  
  private handleChangeEvent(event: any): void {
    const { groupId, changes, timestamp, timestampMs } = event;
    
    // Ensure buffer exists
    if (!this.buffers.has(groupId)) {
      this.createBuffer(groupId);
    }
    
    const buffer = this.buffers.get(groupId)!;
    const groupLastValues = this.lastValues.get(groupId) || new Map();
    
    // Process each change
    for (const change of changes) {
      const previousValue = groupLastValues.get(change.Name);
      
      const cachedEvent: CachedEvent = {
        groupId,
        controlName: change.Name,
        timestamp,
        timestampMs,
        value: change.Value,
        string: change.String,
        previousValue,
        previousString: previousValue?.toString(),
        delta: this.calculateDelta(previousValue, change.Value),
        duration: this.calculateDuration(groupId, change.Name),
        sequenceNumber: this.globalSequence++
      };
      
      buffer.add(cachedEvent);
      groupLastValues.set(change.Name, change.Value);
    }
    
    this.lastValues.set(groupId, groupLastValues);
    this.emit('eventsStored', { groupId, count: changes.length });
  }
  
  query(params: EventQuery): CachedEvent[] {
    const {
      groupId,
      startTime = Date.now() - 60000,
      endTime = Date.now(),
      controlNames,
      valueFilter,
      limit = 1000
    } = params;
    
    let results: CachedEvent[] = [];
    
    // Query relevant buffers
    const buffersToQuery = groupId 
      ? [this.buffers.get(groupId)].filter(Boolean)
      : Array.from(this.buffers.values());
    
    for (const buffer of buffersToQuery) {
      const events = buffer.queryTimeRange(
        BigInt(startTime * 1_000_000),
        BigInt(endTime * 1_000_000)
      );
      
      // Apply filters
      let filtered = events;
      
      if (controlNames) {
        filtered = filtered.filter(e => controlNames.includes(e.controlName));
      }
      
      if (valueFilter) {
        filtered = this.applyValueFilter(filtered, valueFilter);
      }
      
      results.push(...filtered);
    }
    
    // Sort by timestamp and apply limit
    results.sort((a, b) => Number(a.timestamp - b.timestamp));
    return results.slice(0, limit);
  }
  
  private applyValueFilter(
    events: CachedEvent[], 
    filter: EventQuery['valueFilter']
  ): CachedEvent[] {
    const { operator, value } = filter!;
    
    return events.filter(event => {
      switch (operator) {
        case 'eq': return event.value === value;
        case 'neq': return event.value !== value;
        case 'gt': return Number(event.value) > Number(value);
        case 'lt': return Number(event.value) < Number(value);
        case 'changed_to': 
          return event.value === value && event.previousValue !== value;
        case 'changed_from':
          return event.previousValue === value && event.value !== value;
        default: return true;
      }
    });
  }
  
  getStatistics(groupId: string): any {
    const buffer = this.buffers.get(groupId);
    if (!buffer) return null;
    
    return {
      eventCount: buffer.size,
      oldestEvent: buffer.getOldest()?.timestampMs,
      newestEvent: buffer.getNewest()?.timestampMs,
      memoryUsage: buffer.getMemoryUsage()
    };
  }
}

// Integration with MCP Tools
export function createReadChangeGroupEventsTool(eventCache: EventCacheManager) {
  return {
    name: "read_change_group_events",
    execute: async (params: EventQuery) => {
      const events = eventCache.query(params);
      return {
        events,
        count: events.length,
        timeRange: {
          start: params.startTime || Date.now() - 60000,
          end: params.endTime || Date.now()
        }
      };
    }
  };
}
```

## Workaround
Manual polling and external logging could capture some data, but lacks the query capabilities and integration needed for the full solution.

## Test Cases
- [ ] Unit test event capture from QRWCAdapter
- [ ] Test circular buffer creation and management
- [ ] Test time-range queries with various parameters
- [ ] Test control name filtering
- [ ] Test value filter operators (eq, changed_to, etc.)
- [ ] Integration test with Change Groups
- [ ] Performance test with 1000+ events/second
- [ ] Memory usage validation
- [ ] Test query result ordering and limits

## Related Issues
- Depends on: BUG-070 (EventEmitter in QRWCAdapter)
- Depends on: BUG-071 (Circular Buffer Infrastructure)
- Blocks: Time-series query MCP tools
- Related to: Event Cache Implementation Plan

## Additional Context
- Critical for debugging "what happened" scenarios
- Enables pattern detection and anomaly analysis
- Must handle high-frequency updates (33Hz)
- Consider implementing query result caching
- May need background compression for old events

## Acceptance Criteria
- [ ] Event Cache Manager implemented
- [ ] Captures all Change Group events automatically
- [ ] Stores events with proper timestamps and metadata
- [ ] Query interface supports all planned operators
- [ ] Memory usage stays within configured limits
- [ ] MCP tool integration complete
- [ ] Performance meets 33Hz requirement
- [ ] All tests pass

## Notes
This is the core component that brings together event emission (BUG-070) and storage (BUG-071) to provide the complete event caching solution. Consider implementing a plugin architecture to allow different storage backends in the future.

---
**Labels**: bug, feature, state-management, mcp-tools, high-priority  
**Milestone**: Event Cache Implementation
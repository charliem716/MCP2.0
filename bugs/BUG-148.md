# BUG-148: Multiple state management files need logger dependency injection

**Status**: Open  
**Severity**: Medium  
**Priority**: P2 (Medium)  
**Component**: mcp/state/*  
**Reported Date**: 2025-01-31  
**Reporter**: Assistant  
**Assignee**: Unassigned

## Summary

Multiple files in the state management layer directly create logger instances, preventing proper test mocking and requiring dependency injection refactoring.

## Description

Several state management files import and create loggers directly:

- `src/mcp/state/factory.ts`
- `src/mcp/state/simple-state-manager.ts`
- `src/mcp/state/lru-cache.ts`

This pattern prevents tests from injecting mock loggers and forces the use of unreliable ES module mocking techniques.

## Steps to Reproduce

1. Examine the listed state management files
2. Observe direct logger imports and creation
3. Try to write tests that mock logger behavior
4. Tests fail or require complex workarounds

## Expected Behavior

All state management classes should accept optional logger instances through dependency injection.

## Actual Behavior

State management classes create their own logger instances directly, making them difficult to test properly.

## Environment

- **OS**: All
- **Node.js Version**: v20+
- **Project Version/Commit**: Current main branch
- **Jest Version**: 29.x with ES modules

## Error Logs/Stack Trace

```typescript
// Example from state files
import { createLogger } from '../../shared/utils/logger.js';

class SimpleStateManager {
  private logger = createLogger('SimpleStateManager'); // Direct creation
}
```

## Root Cause Analysis

- **File(s)**: 
  - src/mcp/state/factory.ts
  - src/mcp/state/simple-state-manager.ts
  - src/mcp/state/lru-cache.ts
- **Cause**: Direct logger instantiation in class properties or constructors

## Proposed Solution

For each affected file, implement the same DI pattern:

```typescript
// Example for SimpleStateManager
export interface StateManagerOptions {
  logger?: Logger;
  // ... other existing options
}

class SimpleStateManager {
  private logger: Logger;
  
  constructor(options: StateManagerOptions = {}) {
    this.logger = options.logger ?? createLogger('SimpleStateManager');
    // ... rest of initialization
  }
}

// Similar pattern for LRUCache
export interface LRUCacheOptions<K, V> {
  maxSize: number;
  logger?: Logger;
  // ... other options
}

// And for StateFactory
export interface StateFactoryOptions {
  logger?: Logger;
  // ... other options
}
```

## Workaround

Currently requires complex ES module mocking or avoiding logger-related test assertions.

## Test Cases

- [ ] Unit tests for each class with mock logger injection
- [ ] Unit tests for default logger creation
- [ ] Integration tests with custom loggers
- [ ] Verify logger is used correctly in each class
- [ ] Ensure no breaking changes to existing APIs

## Related Issues

- Related to: BUG-145, BUG-146 (Other DI refactoring)
- Part of: DI refactoring initiative

## Additional Context

- State management is a critical component
- Improving testability here will significantly help overall coverage
- Should follow the same pattern established in error-recovery.ts

## Acceptance Criteria

- [ ] All three state management files support logger DI
- [ ] Tests can inject mock loggers successfully
- [ ] No breaking changes to existing APIs
- [ ] All existing tests pass
- [ ] New tests demonstrate DI pattern for each class

## Notes

These files are grouped together as they're all in the state management layer and can be refactored using the same pattern.

---

**Labels**: bug, refactoring, testing, dependency-injection, state-management  
**Milestone**: Test Infrastructure Improvement
# BUG-034: Change Group Methods Not Implemented in Adapter

**Severity**: High  
**Status**: Open  
**Component**: QRWC Adapter  
**Phase**: 2  
**Date**: 2024-01-20  

## Description
The Q-SYS API specification defines comprehensive Change Group methods for efficient polling of control changes. While type definitions and some infrastructure exist (ChangeGroupManager, types), the actual API methods are not implemented in the QRWC adapter.

## Location
- `src/mcp/qrwc/adapter.ts` - Missing Change Group method implementations
- `src/mcp/state/change-group/` - Existing manager infrastructure
- `src/shared/types/qsys.ts` - Type definitions exist

## API Methods Missing
From qrc-reference.md:
1. `ChangeGroup.AddControl` - Add controls to a change group
2. `ChangeGroup.AddComponentControl` - Add component controls to a change group
3. `ChangeGroup.Remove` - Remove controls from a change group
4. `ChangeGroup.Poll` - Poll for changes
5. `ChangeGroup.Destroy` - Destroy a change group
6. `ChangeGroup.Invalidate` - Force resend of all controls
7. `ChangeGroup.Clear` - Remove all controls
8. `ChangeGroup.AutoPoll` - Set up automatic polling

## Example API Usage
```json
// Add control to change group
{
  "jsonrpc": "2.0",
  "id": 1234,
  "method": "ChangeGroup.AddControl", 
  "params": {
    "Id": "my change group",
    "Controls": ["some control", "another control"]
  }
}

// Poll for changes
{
  "jsonrpc": "2.0",
  "id": 1234,
  "method": "ChangeGroup.Poll", 
  "params": {
    "Id": "my change group"
  }
}

// Response
{
  "jsonrpc": "2.0",
  "id": 1234,
  "result": {
    "Id": "my change group", 
    "Changes": [
      {
        "Name": "some control", 
        "Value": -12,
        "String": "-12dB"
      }
    ]
  }
}
```

## Current State
- `ChangeGroupManager` exists but is not connected to adapter
- Type definitions exist in `QSysMethod` enum
- No adapter cases for Change Group methods

## Proposed Implementation

```typescript
// In adapter.ts executeCommand method:

case "ChangeGroup.AddControl":
  const addId = params?.['Id'];
  const addControls = params?.['Controls'] || [];
  
  if (!addId) throw new Error("Change group ID required");
  
  // Get or create change group
  let changeGroup = this.changeGroups.get(addId);
  if (!changeGroup) {
    changeGroup = await this.changeGroupManager.createChangeGroup(addId);
    this.changeGroups.set(addId, changeGroup);
  }
  
  // Add controls to group
  for (const control of addControls) {
    await this.changeGroupManager.addControl(addId, control);
  }
  
  return { result: true };

case "ChangeGroup.Poll":
  const pollId = params?.['Id'];
  if (!pollId) throw new Error("Change group ID required");
  
  const changes = await this.changeGroupManager.poll(pollId);
  
  return {
    result: {
      Id: pollId,
      Changes: changes.map(change => ({
        Name: change.controlName,
        Value: change.newValue,
        String: change.stringValue || String(change.newValue),
        Component: change.componentName
      }))
    }
  };

case "ChangeGroup.AutoPoll":
  const autoPollId = params?.['Id'];
  const rate = params?.['Rate'] || 1; // seconds
  
  if (!autoPollId) throw new Error("Change group ID required");
  
  // Set up automatic polling
  await this.changeGroupManager.setAutoPoll(autoPollId, true, rate * 1000);
  
  return { result: true };

// Additional methods follow similar patterns...
```

## Integration Requirements
1. Connect ChangeGroupManager to adapter
2. Store change group instances in adapter
3. Handle automatic polling with timers
4. Integrate with existing state synchronization
5. Proper cleanup on disconnect

## Benefits
- Efficient monitoring of specific controls
- Reduced network traffic vs polling all controls
- Support for automation and monitoring applications
- Matches Q-SYS Designer scripting capabilities

## Test Requirements
1. Create and destroy change groups
2. Add/remove controls dynamically
3. Poll for changes manually
4. Test automatic polling at different rates
5. Verify change detection accuracy
6. Test with component controls
7. Verify cleanup on disconnect
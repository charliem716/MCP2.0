# BUG-083: Code Complexity Violations in Event Cache Module

**Status**: Open
**Priority**: Medium
**Component**: Event Cache
**Created**: 2025-01-23

## Summary

Several methods in the event cache module exceed complexity limits, making the code difficult to understand, test, and maintain. This includes violations of both `max-statements` and `complexity` rules.

## Affected Methods

### 1. EventCacheManager Methods

**`compressBufferEvents` (manager.ts:828-978)**
- Statements: 51 (limit: 20)
- Complexity: 21 (limit: 15)
- Issues: Deeply nested loops and conditions

**`processCompressionBatch` (manager.ts:722-823)**
- Statements: 46 (limit: 20)
- Complexity: 17 (limit: 15)
- Issues: Multiple branching paths and conditions

**`handleMemoryPressure` (manager.ts:1126-1275)**
- Statements: 45 (limit: 20)
- Complexity: 28 (limit: 15)
- Issues: Three-pass algorithm with complex logic

**`handleChangeEvent` (manager.ts:260-338)**
- Statements: 29 (limit: 20)
- Complexity: 11 (acceptable but high)

### 2. Disk Spillover Manager Methods

**`spillToDisk` (disk-spillover.ts:147-248)**
- Statements: 36 (limit: 20)
- Complexity: 13 (acceptable but high)

## Example of Complex Code

```typescript
// Current complex method
private async compressBufferEvents(
  buffer: CircularBuffer<BufferEvent<T>>,
  groupId: string
): Promise<number> {
  // 51 statements with 21 complexity points
  // Multiple nested loops and conditions
  // Difficult to test and understand
}
```

## Root Cause

1. **Single Responsibility Violation**: Methods doing too many things
2. **Lack of Abstraction**: Complex logic not broken into helper methods
3. **Inline Logic**: Business rules embedded in implementation
4. **Multiple Exit Points**: Complex branching with many return statements

## Proposed Fix

### 1. Extract Helper Methods
```typescript
// Before
private async compressBufferEvents(...) {
  // 51 statements of complex logic
}

// After
private async compressBufferEvents(...) {
  const events = this.getEventsForCompression(buffer, groupId);
  const grouped = this.groupEventsByControl(events);
  const compressed = await this.applyCompressionRules(grouped);
  return this.updateBufferWithCompressed(buffer, compressed);
}
```

### 2. Use Strategy Pattern for Compression
```typescript
interface CompressionStrategy {
  shouldCompress(events: Event[]): boolean;
  compress(events: Event[]): Event[];
}

class RecentWindowStrategy implements CompressionStrategy { }
class MediumWindowStrategy implements CompressionStrategy { }
class AncientWindowStrategy implements CompressionStrategy { }
```

### 3. Simplify Memory Pressure Handling
```typescript
// Extract each pass into its own method
private async handleMemoryPressure(usage: number): Promise<void> {
  const passes = [
    this.memoryPressurePass1,
    this.memoryPressurePass2,
    this.memoryPressurePass3
  ];
  
  for (const pass of passes) {
    if (await pass(usage)) break;
  }
}
```

## Impact

- **Medium**: Complex code is harder to maintain and more bug-prone
- **Testing**: Difficult to achieve high test coverage
- **Performance**: May have hidden inefficiencies
- **Maintainability**: New developers struggle to understand the code

## Implementation Steps

1. **Identify extraction points** in each complex method
2. **Create helper methods** with single responsibilities
3. **Add unit tests** for each extracted method
4. **Use design patterns** where appropriate (Strategy, Chain of Responsibility)
5. **Document complex algorithms** with clear comments
6. **Consider using state machines** for complex state transitions
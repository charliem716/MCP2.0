# BUG-005: Inefficient Change Group Implementation

**Date Reported:** 2024-01-09  
**Severity:** Low  
**Status:** Open  
**Reporter:** System Verification  
**Component:** QRC Commands  

## Description
Change groups are stored in memory without persistence or cleanup mechanisms. This could lead to memory leaks in long-running applications and loss of state on restart.

## Current Implementation
```typescript
export class QRCCommands {
  private changeGroups = new Map<string, QSysChangeGroup>();
  
  createChangeGroup(id: string, controls: Array<{ control: string; component?: string }>): QSysChangeGroup {
    const changeGroup: QSysChangeGroup = {
      id,
      controls,
      autoPoll: false
    };
    
    this.changeGroups.set(id, changeGroup);
    return changeGroup;
  }
}
```

## Issues
1. **No Persistence**
   - Change groups lost on application restart
   - No way to recover active change groups
   - State not synchronized with Q-SYS Core

2. **No Automatic Cleanup**
   - Change groups accumulate indefinitely
   - No TTL or expiration mechanism
   - Manual deletion required

3. **Memory Growth**
   - Unbounded Map growth
   - No maximum size limits
   - Could exhaust memory over time

## Proposed Solutions

### 1. Add TTL and Cleanup
```typescript
interface QSysChangeGroupWithMeta extends QSysChangeGroup {
  createdAt: number;
  lastAccessed: number;
  ttl?: number;
}

private cleanupStaleChangeGroups(): void {
  const now = Date.now();
  for (const [id, group] of this.changeGroups) {
    if (group.ttl && now - group.lastAccessed > group.ttl) {
      this.changeGroups.delete(id);
    }
  }
}
```

### 2. Implement Size Limits
```typescript
private readonly MAX_CHANGE_GROUPS = 1000;

createChangeGroup(...): QSysChangeGroup {
  if (this.changeGroups.size >= this.MAX_CHANGE_GROUPS) {
    // Remove oldest or least recently used
    this.evictOldestChangeGroup();
  }
  // ... create new group
}
```

### 3. Add Persistence Option
```typescript
interface ChangeGroupPersistence {
  save(groups: Map<string, QSysChangeGroup>): Promise<void>;
  load(): Promise<Map<string, QSysChangeGroup>>;
}
```

## Impact
- Memory usage grows unbounded
- State lost on restart
- No automatic resource management
- Could affect long-running deployments

## Acceptance Criteria
- Automatic cleanup of stale change groups
- Configurable memory limits
- Optional persistence mechanism
- Metrics for change group usage
- Unit tests for lifecycle management

## Priority
Low - Only affects long-running applications with heavy change group usage. 
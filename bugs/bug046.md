# BUG-046: Excessive Disconnect Logging During Shutdown

## Status: ACTIVE

## Description
When disconnecting from Q-SYS Core, the system logs hundreds of thousands of identical "Disconnecting from Q-SYS Core" messages, causing log spam and potential memory issues. The debug test showed over 200MB of repeated disconnect logs.

## Affected Components
- `src/qrwc/officialClient.ts` - Disconnect handling
- `src/shared/utils/logger.ts` - Logging system

## Current Behavior
```
{"level":"info","message":"Disconnecting from Q-SYS Core"...}
{"level":"info","message":"Disconnecting from Q-SYS Core"...}
{"level":"info","message":"Disconnecting from Q-SYS Core"...}
... (repeated millions of times)
```

## Expected Behavior
- Single "Disconnecting from Q-SYS Core" message
- Single "Disconnected successfully" message
- Clean shutdown without log spam

## Root Cause
Likely causes:
1. Recursive disconnect calls without proper state checking
2. Event handler triggering multiple disconnects
3. Missing disconnect state flag
4. Circular event emission during shutdown

## Code Analysis
The disconnect method might be:
- Called from multiple event handlers
- Triggering events that cause more disconnect calls
- Missing a "disconnecting in progress" flag

## Impact
- **Severity**: MEDIUM
- **Priority**: P2
- Causes massive log files (200MB+)
- May cause out-of-memory errors
- Makes debugging difficult
- Slows down shutdown process

## Proposed Fix

### 1. Add disconnect state tracking
```typescript
private disconnectInProgress = false;

async disconnect(): Promise<void> {
  if (this.disconnectInProgress || this.connectionState === ConnectionState.DISCONNECTED) {
    return;
  }
  
  this.disconnectInProgress = true;
  this.logger.info('Disconnecting from Q-SYS Core');
  
  try {
    // Actual disconnect logic
    await this.doDisconnect();
    this.logger.info('Disconnected successfully');
  } finally {
    this.disconnectInProgress = false;
  }
}
```

### 2. Fix event handler cleanup
```typescript
private cleanup(): void {
  // Remove all listeners before disconnecting
  this.removeAllListeners();
  
  // Clear any pending timers
  if (this.reconnectTimer) {
    clearTimeout(this.reconnectTimer);
  }
}
```

### 3. Add logging guards
```typescript
private lastLogTime = 0;
private logThrottle = 1000; // 1 second

private logOnce(message: string): void {
  const now = Date.now();
  if (now - this.lastLogTime > this.logThrottle) {
    this.logger.info(message);
    this.lastLogTime = now;
  }
}
```

## Test Case
```javascript
// Should only see 1-2 disconnect messages
const client = new OfficialQRWCClient(config);
await client.connect();

// Capture logs
const logs = [];
logger.on('data', (log) => logs.push(log));

await client.disconnect();

// Verify minimal disconnect logs
const disconnectLogs = logs.filter(log => 
  log.message.includes('Disconnecting')
);
expect(disconnectLogs.length).toBeLessThan(5);
```

## Debugging Steps
1. Add state logging to track disconnect flow
2. Set breakpoints in disconnect method
3. Trace event handler calls during shutdown
4. Monitor memory usage during disconnect

## Files to Modify
- `src/qrwc/officialClient.ts` - Add disconnect state management
- Event handler cleanup in shutdown methods
- Add recursion prevention

## Verification Steps
1. Run debug test and monitor log size
2. Verify clean disconnect with 1-2 log messages
3. Check no memory leaks during shutdown
4. Test rapid connect/disconnect cycles